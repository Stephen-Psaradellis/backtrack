<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Avatar 3D Renderer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }
    #canvas-container {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

  <!-- Avatar Renderer (inline for WebView compatibility) -->
  <script>
    /**
     * Avatar 3D Renderer - Three.js scene setup
     * Inline version for WebView bundle (CDN script loading can be unreliable in WebView)
     */
    (function () {
      'use strict';

      // State
      let scene = null;
      let camera = null;
      let renderer = null;
      let cube = null;
      let animationId = null;
      let isRotating = true;

      // FPS tracking
      let frameCount = 0;
      let lastFpsTime = performance.now();
      let currentFps = 60;

      // Message Bridge
      function sendToRN(message) {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify(message));
        } else {
          console.log('[AvatarRenderer] Would send to RN:', message);
        }
      }

      function handleMessage(event) {
        try {
          const message =
            typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (message.type) {
            case 'SET_CONFIG':
              handleSetConfig(message.config);
              break;
            case 'TAKE_SNAPSHOT':
              handleTakeSnapshot(message.format, message.quality);
              break;
            case 'SET_ROTATION':
              isRotating = message.enabled !== false;
              break;
            default:
              console.warn('[AvatarRenderer] Unknown message type:', message.type);
          }
        } catch (error) {
          sendToRN({
            type: 'ERROR',
            message: error.message,
            code: 'MESSAGE_PARSE_ERROR',
          });
        }
      }

      // Scene Setup
      function createScene(container) {
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        camera.position.set(0, 0, 5);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        if (THREE.SRGBColorSpace) {
          renderer.outputColorSpace = THREE.SRGBColorSpace;
        }

        container.appendChild(renderer.domElement);
        return { scene, camera, renderer };
      }

      function createLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1);
        keyLight.position.set(5, 5, 5);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xb9d5ff, 0.3);
        fillLight.position.set(-3, 3, -3);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xffd9b4, 0.5);
        rimLight.position.set(0, 5, -5);
        scene.add(rimLight);
      }

      function createTestCube() {
        const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const material = new THREE.MeshStandardMaterial({
          color: 0x6366f1,
          metalness: 0.3,
          roughness: 0.4,
        });

        cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        return cube;
      }

      // Animation
      function animate() {
        animationId = requestAnimationFrame(animate);

        if (isRotating && cube) {
          cube.rotation.x += 0.01;
          cube.rotation.y += 0.015;
        }

        frameCount++;
        const now = performance.now();
        if (now - lastFpsTime >= 1000) {
          currentFps = frameCount;
          frameCount = 0;
          lastFpsTime = now;
        }

        renderer.render(scene, camera);
      }

      // Message Handlers
      function handleSetConfig(config) {
        if (!config || !cube) return;

        if (config.primaryColor) {
          const colorHex = config.primaryColor.replace('#', '0x');
          cube.material.color.setHex(parseInt(colorHex));
        }

        if (config.scale) {
          cube.scale.setScalar(config.scale);
        }

        console.log('[AvatarRenderer] Config updated:', config);
      }

      function handleTakeSnapshot(format, quality) {
        format = format || 'png';
        quality = quality || 0.92;

        try {
          renderer.render(scene, camera);
          const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
          const base64 = renderer.domElement.toDataURL(mimeType, quality);

          sendToRN({
            type: 'SNAPSHOT_RESULT',
            base64: base64,
          });
        } catch (error) {
          sendToRN({
            type: 'ERROR',
            message: error.message,
            code: 'SNAPSHOT_ERROR',
          });
        }
      }

      function onWindowResize() {
        const container = document.getElementById('canvas-container');
        if (!container || !camera || !renderer) return;

        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      // Initialization
      function init() {
        const container = document.getElementById('canvas-container');
        if (!container) {
          sendToRN({
            type: 'ERROR',
            message: 'Canvas container not found',
            code: 'INIT_ERROR',
          });
          return;
        }

        try {
          createScene(container);
          createLighting();
          createTestCube();
          window.addEventListener('resize', onWindowResize);
          animate();
          sendToRN({ type: 'READY' });
          console.log('[AvatarRenderer] Initialized successfully');
        } catch (error) {
          console.error('[AvatarRenderer] Init error:', error);
          sendToRN({
            type: 'ERROR',
            message: error.message,
            code: 'INIT_ERROR',
          });
        }
      }

      // Public API
      window.AvatarRenderer = {
        getFps: function() { return currentFps; },
        setConfig: handleSetConfig,
        takeSnapshot: handleTakeSnapshot,
        setRotation: function(enabled) { isRotating = enabled; },
      };

      // Message listeners
      window.addEventListener('message', handleMessage);
      document.addEventListener('message', handleMessage);

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
